import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform

plugins {
    id 'java'
    alias( libs.plugins.enonic.defaults )
    alias( libs.plugins.node.gradle )
}
group = 'com.enonic.app.contentstudio.js_testing'

configurations {
    distro
    deploy
    apps {
        transitive false
    }
}

def unpackDir = layout.buildDirectory.dir( 'install' ).get()
def distroDir = unpackDir.dir( "enonic-xp-generic-$xpVersion" )
def appDir = "$projectDir/test-applications"
def xpHome = "$distroDir/home"
def deployDir = distroDir.dir( 'home/deploy' )
def licenseDir = distroDir.dir( 'home/license' )
def configDir = "$xpHome/config"
def contentStudioPlusFile = "$deployDir/contentstudio.plus-${version}.jar"
def contentStudioPlusAppUrl = project.hasProperty( 'contentStudioPlusAppUrl' ) ? contentStudioPlusAppUrl : "file:///$projectDir/../build/libs/contentstudio.plus.jar"

dependencies {
    distro "com.enonic.xp:enonic-xp-generic:$xpVersion@tgz"
    deploy "com.enonic.app:contentstudio:$libContentStudioVersion@jar"
    apps "com.enonic.uitest:contenttypes:1.0.0-SNAPSHOT"
}

tasks.register( 'unpackDistro', Copy ) {
    description = 'Unpacks the XP distribution for testing'
    group = 'setup'
    println '*********************************************************'
    println '* download and unpack Distro  *'
    println '*********************************************************'
    from {
        configurations.distro.collect { tarTree( it ) }
    }
    into unpackDir
}

tasks.register( 'copyLicense', Copy ) {
    description = 'Copies license file to the test environment'
    group = 'setup'
    doLast {
        println 'Copy license'
    }
    from file( rootProject.projectDir )
    include 'enonic.platform.subscription.lic'
    into licenseDir
    mustRunAfter tasks.named('unpackDistro')
}

tasks.register( 'copyConfig', Copy ) {
    description = 'Copies configuration files to the test environment'
    group = 'setup'
    doLast {
        println "$testConfDir${File.separator}common-config"
    }
    from "$testConfDir${File.separator}common-config"
    include '**.*.cfg'
    include '*.properties'
    into configDir
    mustRunAfter tasks.named('unpackDistro')
}

tasks.register( 'downloadApps', Copy ) {
    description = 'Downloads required apps for testing'
    group = 'setup'
    from {
        configurations.apps
    }
    into deployDir
    mustRunAfter tasks.named( 'unpackDistro' )
}

tasks.register( 'copyApps', Copy ) {
    description = 'Copies application JAR files to deploy directory'
    group = 'setup'
    doLast {
        println 'Task downloadApps completed successfully.'
        println 'Downloaded artifacts:'
        configurations.apps.files.each { file ->
            println "- ${file.name}"
        }
}

tasks.register( 'deployContentStudio', Copy ) {
    description = 'Deploys Content Studio application'
    group = 'deployment'

    println '*********************************************************'
    println '* deployContentStudio  *'
    println '*********************************************************'

    description = 'Deploy Content Studio application'
    group = 'setup'

    from {
        configurations.deploy
    }
    into deployDir
    mustRunAfter tasks.named( 'unpackDistro' )
}

tasks.register( 'deployContentStudioPlus', DefaultTask ) {
    description = 'Deploys Content Studio Plus application'
    group = 'deployment'

    println '*********************************************************'
    println '* deployContentStudio Plus *'
    println '*********************************************************'

    description = 'Deploy Content Studio Plus application'
    group = 'setup'

    outputs.files( contentStudioPlusFile )
    doLast {
        println 'Retrieving Content Studio Plus App from:'
        println contentStudioPlusAppUrl
        println 'Deploying to:'
        println contentStudioPlusFile

        def f = new File( contentStudioPlusFile )
        if ( !f.exists() ) {
            new URL( contentStudioPlusAppUrl ).withInputStream { i -> f.withOutputStream { it << i } }
            println 'Content Studio Plus App is downloaded.'
        }
        else {
            println 'Content Studio Plus App already exists.'
        }
    }
    mustRunAfter tasks.named('unpackDistro')
}


def process
tasks.register( 'startServer' ) {
    description = 'Starts the XP server for testing'
    group = 'testing'
    dependsOn( tasks.named( 'pnpmInstall' ), tasks.named( 'unpackDistro' ), tasks.named( 'copyConfig' ), tasks.named( 'copyLicense' ), tasks.named( 'deployContentStudio' ), tasks.named( 'deployContentStudioPlus' ), tasks.named( 'downloadApps' ) )

    println '*********************************************************'
    println '* startServer  *'
    println '*********************************************************'

    description = 'Start XP server'
    group = 'server'

    doLast {
        sleep(5000)
        println 'Starting XP Server...'
        def pb
        if ( DefaultNativePlatform.getCurrentOperatingSystem().windows ) {
            pb = new ProcessBuilder( 'cmd', '/c', "${distroDir}\\bin\\server.bat" )
        }
        else {
            pb = new ProcessBuilder( "${distroDir}/bin/server.sh" )
        }
        Map<String, String> env = pb.environment()
        env.put( 'XP_HOME', "${xpHome}".toString() )

        def logsPath = layout.buildDirectory.dir( 'reports/logs' ).get()
        mkdir logsPath.asFile
        pb.redirectOutput( logsPath.file( 'xp.log' ).asFile )
        pb.redirectErrorStream( true )
        process = pb.start()
        sleep(60000)
    }
}


tasks.register( 'stopServer' ) {
    description = 'Stops the XP server'
    group = 'testing'
    doLast {
        if (!project.hasProperty('process')) {
            println "Server process not found. It might already be stopped."
            return
        }

        def os = DefaultNativePlatform.currentOperatingSystem
        def pid = process.pid()

        if (os.isWindows()) {
            println "Stopping process with PID ${pid} on Windows..."
            exec {
                commandLine 'taskkill', '/F', '/T', '/PID', pid.toString()
                ignoreExitValue = true // Don't fail if the process is already gone
            }
        } else { // For macOS, Linux, and other Unix-like systems
            println "Stopping process with PID ${pid} on ${os.displayName}..."
            exec {
                commandLine 'kill', '-9', pid.toString()
                ignoreExitValue = true // Don't fail if the process is already gone
            }
        }

        // Clean up the process property
        project.ext.process = null
    }
}

tasks.register( 'cleanup', Delete ) {
    description = 'Cleans up test reports'
    group = 'cleanup'
    delete './build/reports/allure'
}

tasks.register('generateReportAndStopServer', PnpmTask ) {
    description = 'Generates test report and stops server'
    group = 'reporting'
    args = ['run', 'allure-report']
    finalizedBy tasks.named( 'cleanup' )
    finalizedBy tasks.named( 'stopServer' )
}

tasks.register( 'w_testCSPlusChrome', PnpmTask ) {
    description = 'Runs Content Studio Plus tests in Chrome'
    group = 'testing'
    dependsOn( tasks.named( 'pnpmInstall' ), tasks.named('downloadApps'), dependsOn tasks.named('copyConfig'), tasks.named( 'startServer' ) )
    args = ['run', 'test_cs_plus:wdio_chrome']
    finalizedBy tasks.named( 'generateReportAndStopServer' )
}

tasks.register( 'w_testAdminHomeChromeLocal', PnpmTask ) {
    description = 'Runs local admin home tests in Chrome'
    group = 'testing'
    dependsOn( tasks.named( 'pnpmInstall' ) )
    args = ['run', 'test_cs_plus:wdio_chrome']
}

tasks.register( 'yolo' ) {
    dependsOn tasks.named( 'build' )
}